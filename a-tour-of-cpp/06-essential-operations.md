# Essential Operations

- If a class `X` has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the **full complement of functions**:
    ```cpp
    class X {
    public:
        X(Sometype); // ‘‘ordinary constructor’’: create an object
        X(); // default constructor
        X(const X&); // copy constructor
        X(X&&); // move constructor
        X& operator=(const X&); // copy assignment: clean up target and copy
        X& operator=(X&&); // move assignment: clean up target and move
        ˜X(); // destructor: clean up
    }
    ```

- There are five situations in which an object can be copied or moved:
    - As the source of an assignment
    - As an object initializer
    - As a function argument
    - As a function return value
    - As an exception
- An assignment uses a **copy or move assignment operator**. In principle, the other cases use a **copy or move constructor**.
  - However, a copy or move constructor invocation is often **optimized away** by constructing the object used to initialize right in the target object.
- Except for the **ordinary constructor** these special member functions will be generated by the compiler as needed. If you want to be explicit about generating default implementations, you can:
    ```cpp
    class Y {
    public:
        Y(Sometype);
        Y(const Y&) = default; // I really do want the default copy constructor
        Y(Y&&) = default; // and the default move constructor
    }
    ```
- If you are **explicit** about some defaults, other default definitions will not be generated ⚠️.
- When a class has a **pointer** member, it is usually a good idea to be **explicit** about **copy and move operations**.
- A good rule of thumb (sometimes called the **rule of zero**) is to either define all of the essential operations or none (using the `default` for all).
- **Rule of Zero/Rule of Five**: It encourages you to avoid manually defining special member functions unless you need to manage resources **explicitly**.

## `default` after a special member function

- The `= default;` syntax is used to tell to the compiler to **generate the default** implementation of that function as it normally would if you had not provided any user-defined implementation.
- Make it clear to readers of your code that you're intentionally using the compiler-generated version of the constructor.
- The `= default` keyword allows you to follow this rule while still having explicit control over which constructors and operators are available.

## `delete` after a special member function

- Using `= delete after` tells the compiler to remove that function from the class's interface. This means that if someone tries to use the deleted function, the compiler will generate an error.
- Use cases:
  - If your class manages a resource like dynamic memory, file handles, or network sockets that **should not be copied**, you may want to **delete the copy constructor and copy assignment operator**. This prevents shallow copying, which could lead to double-free errors or resource leaks.
  - You might **delete the move operations** if moving an object would leave it in an invalid or unusable state. For example, if the class represents a unique resource that should never be transferred to another instance, you would delete the move constructor and move assignment operator.
  - If your class **requires specific parameters** to be initialized properly and should not be created **with a default constructor**, you can **delete the default constructor**.
  - **Deleting a destructor** is uncommon, but it can be used to **prevent deletion** of instances through a pointer to a **base class**, ensuring that derived class destructors are always called. This is often used in classes designed to be interfaces or abstract base classes.
  - If you want to **prevent a class from being inherited**, you can **delete the destructor** and make it `protected` or `private`. This ensures that the class cannot be used as a base class.
  - To **prevent slicing** (where a derived class object is copied as a base class object, losing the derived part), you can **delete the copy and assignment operators** in the base class.

## Conversions

- A constructor taking a single argument defines a conversion from its argument type. For example, `complex` provides a constructor from a double:
    ```cpp
    complex z1 = 3.14; // z1 becomes {3.14,0.0}
    complex z2 = z1∗2; // z2 becomes z1*{2.0,0} == {6.28,0.0}
    ```
- This **implicit** conversion is sometimes ideal, but not always. For example, Vector provides a constructor from an int:
    ```cpp
    Vector v1 = 7; // OK: v1 has 7 elements
    ```

## `explicit` keyword

- Using explicit helps in preventing unintended or unexpected type conversions, making the code more explicit and potentially avoiding subtle bugs.
- It's especially useful for constructors that take a single argument or conversion operators, where implicit conversions might lead to unintended behavior.
    ```cpp
    class Vector {
    public:
        explicit Vector(int s); // no implicit conversion from int to Vector
    // ...
    };

    // That gives us:
    Vector v1(7); // OK: v1 has 7 elements
    Vector v2 = 7; // error: no implicit conversion from int to Vector
    ```

## Member Initializers

- When a data member of a class is defined, we can supply a default initializer called a **default member initializer**. Consider a revision of complex:
```cpp
class complex {
        double re = 0;
        double im = 0; // representation: two doubles with default value 0.0
    public:
        complex(double r, double i) :re{r}, im{i} {} // construct complex from two scalars: {r,i}
        complex(double r) :re{r} {} // construct complex from one scalar: {r,0}
        complex() {} // default complex: {0,0}
    // ...
}
```
- The default value is used whenever a constructor doesn’t provide a value. This simplifies code and helps us to avoid accidentally leaving a member **uninitialized**.

## Copy & Move

### Copy Constructor

- is a special type of constructor used to create a new object as a copy of an existing object (of the same type).
- if you do not provide a copy constructor for your classes, C++ will create a public copy constructor for you.
```cpp
- Sample(Sample &t)
```
- A user-defined copy constructor is generally needed when an object owns **pointers** or **non-shareable references**, such as to a file, in which case a destructor and an assignment operator should also be written.
- When a class is a *resource handle* – that is, when the class is responsible for an object accessed through a **pointer** – the default memberwise copy is typically a **disaster**.
  - Memberwise copy would violate the resource handle’s invariant . For example, the default copy would leave a copy of a `Vector` referring to the same elements as the original:
  ```cpp
    void bad_copy(Vector v1)
    {
    Vector v2 = v1; // copy v1’s representation into v2
    v1[0] = 2; // v2[0] is now also 2!
    v2[1] = 3; // v1[1] is now also 3!
    }
    ```

## Copy Assignment Operator

- This operator is called when an **already initialized** object is assigned a new value from another existing object.
    ```c++
    class Widget {
    public:
    Widget(); // default constructor
    Widget(const Widget& rhs); // copy constructor
    Widget& operator=(const Widget& rhs); // copy assignment operator
    ...
    };
    Widget w1; // invoke default constructor
    Widget w2(w1); // invoke copy constructor
    w1 = w2; // invoke copy assignment operator
    ```
- Read carefully when you see what appears to be an assignment, because the `=` syntax can also be used to call the copy constructor: `Widget w3 = w2; // invoke copy constructor!`
- Fortunately, **copy construction** is easy to distinguish from **copy assignment**.
  - If a new object is being defined (such as `w3` in the statement above), a constructor has to be called; it **can’t be an assignment**.
  - If no new object is being defined (such as in the `w1 = w2” statement above), no constructor can be involved, so it’s an **assignment**.
- *Pass-by-value* means *call the copy constructor.*: `bool hasAcceptableQuality(Widget w);`
- *Pass-by-reference-to-const* is typically a better choice.

### Move Constructor

- A move constructor allows you to efficiently **transfer ownership** of resources from one object to another.
- It is used to **avoid unnecessary copying** and improve **performance**, especially when dealing with large objects or objects holding resources like memory or file handles.
- As is typical, `Vector’s` move constructor is trivial to define:
    ```cpp
    Vector::Vector(Vector&& a)
    :elem{a.elem}, // "grab the elements" from a
    sz{a.sz} {
        a.elem = nullptr; // now a has no elements
        a.sz = 0;
    }
    ```
- The `&&` means **rvalue reference** and is a reference to which we can bind an **rvalue**.
- A move constructor does **not** take a **const argument**: after all, a move constructor is supposed to remove the value from its argument. A move assignment is defined similarly.

### LValue vs RValue Reference

- `Lvalue` References ( & )
    - refers to an object that has a **persistent memory** location. Think of it as a "label" pointing to an existing object.
    - Can be **assigned** to or **modified**.
    - Can be used on the **left-hand** side of an **assignment** operator.
    - Can be used as **arguments** to functions that expect `lvalue` references.
    - Examples:
        ```cpp
        int x = 10;     // x is an lvalue
        int& ref = x;   // ref is an lvalue reference to x
        std::cout << x; // x is an lvalue
        ```
- `Rvalue` References ( && )
    - refers to an object that is **not guaranteed** to have a **persistent memory** location. It often represents a **temporary** object or an expression that **doesn't have an identifier**.
    - **Cannot** be **assigned** to or **modified** (except by `move` operations).
    - **Cannot** be used on the **left-hand** side of an **assignment** operator.
    - Can be used as **arguments** to functions that expect `rvalue` references, especially for move operations.
    - Examples:
        ```cpp
        int x = 10; int y = x + 5;  // x + 5 is an rvalue
        std::move(x); // std::move(x) returns an rvalue reference to x
        int&& rref = std::move(x);  // rref is an rvalue reference to x
        ```

## Operator Overloading

- An operator can be defined as a member function:
    ```cpp
    class Matrix {
        Matrix& operator=(const Matrix& a); // assign m to *this; return a reference to *this
    };
    ```
- This is conventionally done for operators that modify their **first operand** and is for historical reasons required for =, −>, (), and []
- Alternatively, most operators can be defined as free-standing functions:
    ```cpp
    Matrix operator+(const Matrix& m1, const Matrix& m2); // assign m1 to m2 and return the sum
    ```
- When defining `==`, also define `!=` and make sure that `a!=b` means `!(a==b).
- Similarly, if you define `<`, also define `<=`, `>`, `>=` to make sure that the usual equivalences hold:
  - `a<=b` means `(a<b)||(a==b) and !(b<a)`.
  - `a>b` means `b<a`.
  - `a>=b` means `(a>b)||(a==b) and !(a<b)`.
- The `<==>` operator in C++ is known as the **three-way comparison** operator or the **spaceship** operator.
  - It was introduced in *C++20* as part of the new comparison features in the language.
  - The `<==>` operator simplifies and unifies the process of comparing two objects by providing a single operator that can perform a three-way comparison, producing a result that indicates whether the first operand is less than, equal to, or greater than the second operand.

## Container Operations

- Rather than traversing containers using indices from `0` to `size()`, the standard algorithms rely on the notion of **sequences** delimited by pairs of **iterators**:
    ```cpp
    for (auto p = c.begin(); p!=c.end(); ++p)
    ∗p = 0;
    ```
- Here, `c.begin()` is an iterator pointing to the first element of `c` and `c.end()` points one-beyond-the-last element of c.
- Like pointers, iterators support `++` to move to the next element and `∗` to access the value of the pointed-to element.
- These `begin()` and `end()` functions are also used by the implementation of the range-for, so we can simplify loops over a range:
    ```cpp
    for (auto& x : c)
        x= 0;
    ```
- Many algorithms, most notably `sort()`, use a `swap()` function that exchanges the values of two objects.
- In an `unordered_map<K,V>`, to use a type `X` as a key, we must define `hash<X>`. For common types, such as std::string, the standard library defines `hash<>` for us

## User-Defined Literals

- Literals with **user-defined suffixes** are called user-defined literals or *UDLs*.
- Such literals are defined using literal operators. A literal operator converts a literal of its argument type, followed by a subscript, into its return type. For example, the `i` for imaginary suffix might be implemented like this:
    ```cpp
    constexpr complex<double> operator""i(long double arg) // imaginary literal
    {
        return {0,arg};
    }
    ```
